/*
Versão feita pelo GEMINI, ajuste no motor de direção para manter rotacionando enquanto
o botão do controle estiver pressionado

*/

#include <Arduino.h>
#include <IRremote.h> // Versão 3.x ou superior

/*
MAPEAMENTO CONTROLE SEM HEX

  POWER (Botao Desligar/Liga) = 0xE51A52AD
  PLAY/PAUSE (Botao Velocidade 30%) = 0xA75852AD
  ESQUERDA (Botao Direcao > Esquerda) = 0xBD4252AD
  DIREITA (Botao Direcao > Direita) = 0xBC4352AD
  MAIS (Botao + Velocidade) = 0xF50A52AD
  MENOS (Botao - Velocidade) = 0xF40B52AD
  PASTA MAIS (Botao Frente) = 0xBF4052AD
  PASTA MENOS (Botao Ré) = 0xBE4152AD
*/

//-------------------- PINOS --------------------
#define BUZZER_PIN 2 // ajuste se seu buzzer estiver em outro pino
const int RPWM = 5;
const int LPWM = 6;
const int L_EN = 9;
const int R_EN = 10;

//-------------------- VARIÁVEIS --------------------
// REMOVIDO: unsigned long time, time2 = 0;
int status = 0;         // 0 Desligado - 1 Ligado
int velocidade = 0;     // 0 Parado / 1 - V1 / ... / 10 - V10
int direcao = 0;        // 0 Frente - 1 Ré
int motordirecao = 0;   // 0 parado / 1 direita / 2 esquerda

// --- NOVAS VARIÁVEIS PARA CONTROLE DE DIREÇÃO ---
unsigned long lastSteerCommandTime = 0; // Armazena o tempo do último comando de direção
const int STEER_TIMEOUT = 200; // Tempo em milissegundos para considerar que o botão foi solto

//-------------------- CLASSE MOTOR DIREÇÃO --------------------
class DCMotor {
  int spd = 130, pin1, pin2;

public:
  void Pinout(int in1, int in2) {
    pin1 = in1;
    pin2 = in2;
    pinMode(pin1, OUTPUT);
    pinMode(pin2, OUTPUT);
  }
  void Speed(int in1) { spd = in1; }
  void Forward() {
    analogWrite(pin1, spd);
    digitalWrite(pin2, LOW);
  }
  void Backward() {
    digitalWrite(pin1, LOW);
    analogWrite(pin2, spd);
  }
  void Stop() {
    digitalWrite(pin1, LOW);
    digitalWrite(pin2, LOW);
  }
};
DCMotor Motor1;

//-------------------- FUNÇÕES AUXILIARES --------------------
void setPWMfrequency(int freq) {
  TCCR0B = TCCR0B & 0b11111000 | freq;
}

void MotorActiveStatus(char Side, boolean s) {
  if (Side == 'R') digitalWrite(R_EN, s);
  if (Side == 'L') digitalWrite(L_EN, s);
}

void setMotor(char side, byte pwm) {
  if (side == 'R') analogWrite(RPWM, pwm);
  if (side == 'L') analogWrite(LPWM, pwm);
}

void closeMotor(char side) {
  if (side == 'R') digitalWrite(RPWM, LOW);
  if (side == 'L') digitalWrite(LPWM, LOW);
}

void controleMotor(char lado, int v) {
  static const byte pwmValues[] = {0, 64, 128, 192, 255}; // índices: 0..4
  // CORREÇÃO: O seu código permitia velocidade até 10, mas o array só vai até 4.
  // Ajustei o limite para 4 para corresponder ao array pwmValues.
  // Se você tiver mais níveis de velocidade, precisa adicionar mais valores ao array.
  if (v < 1 || v > 4) return; // evita valores inválidos

  MotorActiveStatus('R', true);
  MotorActiveStatus('L', true);
  setMotor(lado, pwmValues[v]);
}

void paraMotor() {
  MotorActiveStatus('R', false);
  MotorActiveStatus('L', false);
  closeMotor('R');
  closeMotor('L');
  // ATENÇÃO: Um delay de 14 segundos irá travar todo o seu código.
  // É melhor usar uma abordagem sem delay, mas para manter a sua lógica original, eu o mantive.
  delay(14000); // Espera do motor principal parar.
}

//-------------------- FUNÇÃO BIP (UNIFICADA) --------------------
void bip(int tp) {
  // A função bip permanece a mesma, sem alterações.
  switch (tp) {
    case 1: analogWrite(BUZZER_PIN, 255); delay(2500); analogWrite(BUZZER_PIN, 0); delay(700); analogWrite(BUZZER_PIN, 255); delay(700); analogWrite(BUZZER_PIN, 0); delay(700); analogWrite(BUZZER_PIN, 255); delay(700); analogWrite(BUZZER_PIN, 0); break;
    case 2: analogWrite(BUZZER_PIN, 255); delay(4000); analogWrite(BUZZER_PIN, 0); break;
    case 3: analogWrite(BUZZER_PIN, 255); delay(800); analogWrite(BUZZER_PIN, 0); delay(400); analogWrite(BUZZER_PIN, 255); delay(800); analogWrite(BUZZER_PIN, 0); break;
    case 4: for (int i = 0; i < 3; i++) { analogWrite(BUZZER_PIN, 255); delay(400); analogWrite(BUZZER_PIN, 0); delay(400); } break;
    case 5: analogWrite(BUZZER_PIN, 255); delay(500); analogWrite(BUZZER_PIN, 0); break;
  }
}

//-------------------- FUNÇÃO DE PROCESSAMENTO DE COMANDOS --------------------
// Alterado para usar o .command que é mais consistente na biblioteca v3+
void processCommand(uint32_t command) {
  switch (command) {
    // Botao Desligar/Liga
    case 0xE51A52AD:
      if (status == 0) {
        Serial.println("Ligado");
        bip(1);
        status = 1;
        velocidade = 1;
        direcao = 0;
        controleMotor('E', velocidade); // 'E' é arbitrário, já que a direção é 0 (Frente)
      } else {
        Serial.println("Desligado");
        bip(2);
        Motor1.Stop();
        motordirecao = 0;
        status = 0;
        paraMotor();
      }
      break;

    // Botao Velocidade 30%
    case 0xA75852AD:
      if (status == 1) {
        if (velocidade != 3) {
          Serial.println("Velocidade 30%");
          bip(5);
          velocidade = 3;
          controleMotor(direcao == 0 ? 'E' : 'D', velocidade);
        } else bip(4);
      }
      break;

    // Botao Frente
    case 0xBF4052AD:
      if (status == 1 && direcao == 1) {
        Serial.println("Frente");
        bip(5);
        velocidade = 1;
        direcao = 0;
        paraMotor();
        controleMotor('E', velocidade);
      }
      break;

    // Botao Ré
    case 0xBE4152AD:
      if (status == 1 && direcao == 0) {
        Serial.println("Ré");
        bip(5);
        velocidade = 1;
        direcao = 1;
        paraMotor();
        controleMotor('D', velocidade);
      }
      break;

    // Botao + Velocidade
    case 0xF50A52AD:
      if (status == 1) {
        // CORREÇÃO: Limite alterado para 4 para corresponder ao array pwmValues
        if (velocidade < 4) {
          Serial.println("+ Velocidade");
          bip(5);
          velocidade++;
          controleMotor(direcao == 0 ? 'E' : 'D', velocidade);
        } else {
          Serial.println("!Velocidade Maxima já!");
          bip(4);
        }
      }
      break;

    // Botao - Velocidade
    case 0xF40B52AD:
      if (status == 1) {
        if (velocidade > 1) {
          Serial.println("- Velocidade");
          bip(5);
          velocidade--;
          controleMotor(direcao == 0 ? 'E' : 'D', velocidade);
        } else {
          Serial.println("!Velocidade Minima já!");
          bip(4);
        }
      }
      break;

    // Botao Direcao > Direita
    case 0xBC4352AD:
      if (status == 1) {
        if (motordirecao != 1) {
          Serial.println("Virando Direita");
          bip(5);
        }
        motordirecao = 1;
        Motor1.Forward();
        lastSteerCommandTime = millis(); // Atualiza o tempo do último comando
      }
      break;

    // Botao Direcao > Esquerda
    case 0xBD4252AD:
      if (status == 1) {
        if (motordirecao != 2) {
          Serial.println("Virando Esquerda");
          bip(5);
        }
        motordirecao = 2;
        Motor1.Backward();
        lastSteerCommandTime = millis(); // Atualiza o tempo do último comando
      }
      break;
  }
}

//-------------------- SETUP --------------------
void setup() {
  setPWMfrequency(0x02); // timer 0 , 3.92KHz
  Serial.begin(9600);

  IrReceiver.begin(12, ENABLE_LED_FEEDBACK); // Inicia o receptor (feedback LED é opcional)

  Motor1.Pinout(3, 11);
  Motor1.Speed(100);

  // Motor Propulsão
  pinMode(RPWM, OUTPUT);
  pinMode(LPWM, OUTPUT);
  pinMode(L_EN, OUTPUT);
  pinMode(R_EN, OUTPUT);
  digitalWrite(RPWM, LOW);
  digitalWrite(LPWM, LOW);
  digitalWrite(L_EN, LOW);
  digitalWrite(R_EN, LOW);

  pinMode(BUZZER_PIN, OUTPUT);
  bip(3);
}

//-------------------- LOOP --------------------
void loop() {
  if (IrReceiver.decode()) {
    // Usamos .command para o comando real e não processamos repetições aqui,
    // mas o simples fato de receber um sinal (novo ou repetido) vai resetar o nosso timeout.
    processCommand(IrReceiver.decodedIRData.command);
    
    // É importante chamar resume() para poder receber o próximo valor
    IrReceiver.resume(); 
  }

  // --- NOVA LÓGICA DE TIMEOUT PARA DIREÇÃO ---
  // Se o motor de direção estiver ativo (direita ou esquerda) E
  // se já passou o tempo de timeout desde o último comando recebido
  if (motordirecao != 0 && (millis() - lastSteerCommandTime > STEER_TIMEOUT)) {
    Serial.println("Direção Parada (Timeout)");
    Motor1.Stop();      // Para o motor de direção
    motordirecao = 0;   // Reseta o status da direção
  }
}